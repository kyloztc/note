## 基本数据结构/语法
### 基础数据类型
*布尔类型（bool）*：布尔类型只有两个值，true和false。

*整数类型（int、int8、int16、int32、int64、uint、uint8、uint16、uint32、uint64）*：整数类型用于表示整数，其中int类型的大小根据不同的操作系统可能会有所不同，通常为32位或64位。

*浮点数类型（float32、float64）*：浮点数类型用于表示小数，其中float32类型的精度为6位小数，float64类型的精度为15位小数。

*复数类型（complex64、complex128）*：复数类型用于表示复数，其中complex64类型由两个float32类型的实数和虚数组成，complex128类型由两个float64类型的实数和虚数组成。

*字符串类型（string）*：字符串类型用于表示文本字符串，可以包含任意Unicode字符。

*字节类型（byte）*：字节类型用于表示8位无符号整数，通常用于处理二进制数据。

*符文类型（rune）*：符文类型用于表示Unicode字符，通常用于处理文本数据。

### 复合数据类型
*数组（array）*：数组是一组具有相同类型的元素的集合，元素的数量是固定的。数组的定义方式为var a [n]T，其中n表示数组的长度，T表示数组元素的类型。

*切片（slice）*：切片是一个动态数组，可以根据需要动态增加或减少元素的数量。切片的定义方式为var s []T，其中T表示切片元素的类型。

*映射（map）*：映射是一种键值对的集合，可以根据键来访问值。映射的定义方式为var m map[K]V，其中K表示键的类型，V表示值的类型。

*结构体（struct）*：结构体是一种自定义的数据类型，可以包含多个不同类型的字段。结构体的定义方式为type T struct { field1 type1 field2 type2 ... }，其中T表示结构体的类型，field1、field2等表示结构体的字段名，type1、type2等表示字段的类型。

*接口（interface）*：接口是一种抽象的数据类型，定义了一组方法的集合。接口的定义方式为type T interface { method1() type1 method2() type2 ... }，其中T表示接口的类型，method1、method2等表示接口的方法名，type1、type2等表示方法的返回值类型。

*数组和切片的区别*
1. 长度不同：数组的长度是固定的，定义时需要指定长度，而切片的长度是可变的，可以根据需要动态增加或减少元素的数量。

2. 内存分配方式不同：数组在定义时就会分配一段连续的内存空间，而切片则是在运行时动态分配内存空间。

3. 传递方式不同：数组在函数间传递时会进行值拷贝，即传递的是数组的副本，而切片在函数间传递时只会传递一个指向底层数组的指针，不会进行值拷贝。

4. 初始化方式不同：数组可以通过var a [n]T或a := [n]T的方式进行初始化，而切片通常使用make函数进行初始化，例如s := make([]T, n)。

5. 使用方式不同：数组通常用于存储固定数量的元素，而切片通常用于存储可变数量的元素，并且可以方便地进行添加、删除、修改等操作。

*切片的扩容*
当切片的长度（len）等于容量（cap）时，表示切片已经满了，需要进行扩容。

运行时会创建一个新的底层数组，其长度为原有数组的两倍（或更多，具体策略由运行时决定）。

运行时会将原有数组中的元素复制到新的数组中。

运行时会将切片的指针指向新的底层数组，并更新切片的长度和容量。

原有的底层数组会被垃圾回收器回收。
需要注意的是，切片的扩容会导致底层数组重新分配内存空间，因此频繁的扩容会影响程序的性能。为了避免频繁的扩容，可以在创建切片时预估其容量，使用make函数创建切片时可以指定其容量，例如s := make([]T, n, m)，其中n表示切片的长度，m表示切片的容量。这样可以避免切片频繁扩容，提高程序的性能。


## 常用数据结构分析
golang常用库
net/http：用于编写 HTTP 服务器和客户端的库。

database/sql：用于访问关系型数据库的库，支持多种数据库驱动。

encoding/json：用于 JSON 编码和解码的库。

log：用于记录日志的库，支持多种日志级别和输出格式。

time：用于处理时间和日期的库，支持多种时间格式和时区。

sync：用于实现并发同步的库，包括互斥锁、读写锁、条件变量等。

strconv：用于字符串和基本数据类型之间的转换的库。

os：用于操作文件和目录的库，包括文件读写、目录遍历、进程管理等。

flag：用于解析命令行参数的库，支持多种参数类型和默认值。

testing：用于编写单元测试和性能测试的库，支持多种测试方法和断言。

第三方库
cobra：命令行工具开发框架


### sync包
*Mutex*：互斥锁，用于保护临界区，只允许一个 goroutine 进入。

*RWMutex*：读写锁，允许多个 goroutine 同时读取共享资源，但只允许一个 goroutine 写入共享资源。

*WaitGroup*：等待组，用于等待一组 goroutine 完成任务。

*Cond*：条件变量，用于在 goroutine 之间同步和通信。

*Once*：一次性执行，用于保证某个操作只执行一次。

*Map*：并发安全的映射表，可以在多个 goroutine 中安全地读写。
sync.Map 的设计
1. 核心思想
 核心原则就是，尽量使用原子操作，最大程度上减少了锁的使用，从而接近了“lock free"的效果。
+ 使用了两个原生的map作为存储介质，分别是read map和dirty map（只读字典和脏字典）。
+ 只读字典使用atomic.Value来承载，保证原子性和高性能；脏字典则需要用互斥锁来保护，保证了互斥。
+ 只读字典和脏字典中的键值对集合并不是实时同步的，它们在某些时间段内可能会有不同。
+ 无论是read还是dirty，本质上都是map[interface{}]*entry类型，这里的entry其实就是Map的value的容器
+ entry的本质，是一层封装，可以表示具体值的指针，也可以表示key已删除的状态（即逻辑假删除）
+ 过这种设计，规避了原生map无法并发安全delete的问题，同时在变更某个键所对应的值的时候，就也可以使用原子操作了。

集合分布
读字典独有：标记为expunged的键值对
写字段独有：新添加的键值对
交集：标记为nil的键值对，正常键值对

操作具体内容
Store操作（C/U）
+ 如果在读字典中找到key，则尝试直接在读字典写入，成功则直接返回
+ sync.Map上锁，准备写入脏字典，但是在写入脏字典前会做一个双锁校验，避免在间隙期间读字典中出现了目标值，如果读字典中找到对应key了，是正常值则写入并解锁返回，如果是expunged，则将该键的值设置为nil，并添加到脏字典中，保证这个键是两个字典共有的，然后在将新的值写入到对应的值中
+ 如果key存在于脏字典，则写入
+ 如果脏字典中也不存在，则要将读字典的amended字段设置为true，表示当前脏字典已经存在有读字典不存在的key了。如果此时的脏字典为nil，则需要使用读字段初始化脏字典（read=>dirty 会讲read中的nil设置为expunged，不进入脏字典）。
+ 在上述操作之后，在脏字典中新建一个键值对

Load操作（R）
+ 利用原子操作读取读字典，如果找到则返回
+ 如果读字典中没有找到，并且读字典的amended字段为true，则到脏字典中查找对应的键值对，并将miss+1，当miss达到某个阈值后，会将脏字典的内容迁移到读字典中，并将脏字典置为nil（dirty=>read）
+ 如果脏字典也没有，则返回nil

删除操作（D）
与load操作基本一致，也是先读字典，再脏字典，同样会触发脏字典的升级
删除的时候会将值设置为nil

*Pool*：对象池，用于管理可重用的对象，避免频繁地创建和销毁对象。



## golang内存管理
### 内存划分
借鉴TCMalloc Thead-Caching Malloc
1. page 基本管理单位
2. span 一组连续的page被称为span
3. mcache 与ThreadCache类似，mcache保存的是各种大小的Span，并按Span class分类，小对象直接从mcache分配内存，它起到了缓存的作用，并且可以无锁访问。
在go程序中每个P拥有1个mcache
4. mcentral 与TCMalloc中的CentralCache类似，是所有线程共享的缓存，需要加锁访问，它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。 但mcentral与CentralCache也有不同点，CentralCache是每个级别的Span有1个链表，mcache是每个级别的Span有2个链表。
5. mheap mheap与TCMalloc中的PageHeap类似，它是堆内存的抽象，把从OS（系统）申请出的内存页组织成Span，并保存起来。当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。

### 内存分配
对象划分为小对象和大对象，其中小对象细分了一个tiny对象
大对象：大于32KB
小对象：16Byte ~ 32KB
Tiny对象：1Byte ~ 16Byte

为对象寻找span 寻找span的流程如下：

计算对象所需内存大小size

根据size到size class映射，计算出所需的size class

根据size class和对象是否包含指针计算出span class

获取该span class指向的span


## golang垃圾回收
Go 实现的垃圾回收器是无分代（对象没有代际之分）、 不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。 从宏观的角度来看，Go 运行时的垃圾回收器主要包含五个阶段：
| 阶段 | 说明 | 赋值器状态 |
| --- | --- | --- |
| 清扫终止 | 为下一个阶段的并发标记做准备工作，启动写屏障 | STW |
| 标记 | 与赋值器并发执行，写屏障处于开启状态 | 并发 |
| 标记终止 | 保证一个周期内标记任务完成，停止写屏障 | STW |
| 内存清扫 | 将需要回收的内存归还到堆中，写屏障处于关闭状态 | 并发 |
| 内存归还 | 将过多的内存归还给操作系统，写屏障处于关闭状态 | 并发 |

四个阶段的版本：
1. 清理终止阶段；
    1. 暂停程序，所有的处理器在这时会进入安全点（Safe point）；
    2. 如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
2. 标记阶段；
    1. 将状态切换至_GCmark、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；
    2. 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
    3. 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
    4. 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
    5. 使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
3. 标记终止阶段；
    1. 暂停程序、将状态切换至_GCmarktermination并关闭辅助标记的用户程序；
    2. 清理处理器上的线程缓存；
4. 清理阶段；
    1. 将状态切换至_GCoff开始清理阶段，初始化清理状态并关闭写屏障；
    2. 恢复用户程序，所有新创建的对象会标记成白色；
    3. 后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；

### 三色标记
白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

存在的问题：
可能会错误回收：假设某个灰色对象 A 指向白色对象 B， 而此时赋值器并发的将黑色对象 C 指向（ref3）了白色对象 B， 并将灰色对象 A 对白色对象 B 的引用移除（ref2），则在继续扫描的过程中， 白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象）

解决：
+ 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
+ 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径

保证三色不变性
1. 插入写屏障
Dijkstra插入写屏障：是一种相对保守的屏障技术，它会将有存活可能的对象都标记成灰色以满足强三色不变性,新引用的对象会被标记为灰色
对象在内存槽中有两种位置：栈和堆。栈空间的特点是容量小，但要求响应速度快，所以Go语言没有选择启用栈上的写屏障机制。
2. 删除写屏障
Yuasa删除屏障：在老对象的引用被删除时，将白色的老对象涂成灰色

golang在1.8后使用上述两种写屏障构成混合屏障，以此来保证强三色不变性

根集合：垃圾收集器在标记过程中最先检查的对象，包括

+ 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量
+ 执行栈：每个Goroutine都包含自己的执行栈，执行栈上包含栈上变量及指向堆内存的指针
+ 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向堆内存

## 逃逸分析
golang编译器决定内存分配位置的方式（栈或堆），就称之为逃逸分析(escape analysis)。逃逸指的是将内存分配在堆上，而不是在栈上
以下几种情况会发生逃逸
1. 指针逃逸
在函数中创建了一个对象，返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。
2. interface{}动态类型逃逸
如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，就会发生逃逸
3. 栈空间不足
栈空间通常比较小，因此递归函数实现不当时，容易导致栈溢出。
4. 闭包
一个函数如果引用了外部的作用域，那么我们说这个函数和与其相关的引用环境组合而成的实体构成了闭包
在闭包中，被引用的环境会发生逃逸，因为被引用的环境无法因为外部函数的退出而结束生命，依然会存在于内层函数中。

利用逃逸分析提高性能
传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。

## golang协程
### GMP模型
G：表示Goroutine。每个Goroutine 对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。当Goroutine被调离CPU时，调度器代码负责把CPU寄存器的值保存在G对象的成员变量之中，当Goroutine被调度起来运行时，调度器代码又负责把G对象的成员变量所保存的寄存器的值恢复到CPU的寄存器
M：OS底层线程的抽象，它本身就与一个内核线程进行绑定，每个工作线程都有唯一的一个M结构体的实例对象与之对应，它代表着真正执行计算的资源，由操作系统的调度器调度和管理。M结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的Goroutine以及是否空闲等等状态信息之外，还通过指针维持着与P结构体的实例对象之间的绑定关系
P：表示逻辑处理器。对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等。它维护一个局部Goroutine可运行G队列，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列，这可以大大减少锁冲突，提高工作线程的并发性，并且可以良好的运用程序的局部性原理
一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境（内核线程+上下文）。每个P都包含一个可运行的G的队列（runq）。该队列中的G会被依次传递给与本地P关联的M，并获得运行时机。
M与KSE之间总是一一对应的关系，一个M仅能代表一个内核线程。M与KSE之间的关联非常稳固，一个M在其生命周期内，会且仅会与一个KSE产生关联，而M与P、P与G之间的关联都是可变的，M与P也是一对一的关系，P与G则是一对多的关系。

g0和m0
运行时系统中的每个M都会拥有一个特殊的G，一般称为M的g0。M的g0不是由Go程序中的代码间接生成的，而是由Go运行时系统在初始化M时创建并分配给该M的。M的g0一般用于执行调度、垃圾回收、栈管理等方面的任务。M还会拥有一个专用于处理信号的G，称为gsignal。
除了g0和gsignal之外，其他由M运行的G都可以视为用户级别的G，简称用户G，g0和gsignal可称为系统G。Go运行时系统会进行切换，以使每个M都可以交替运行用户G和它的g0。这就是前面所说的“每个M都会运行调度程序”的原因。
除了每个M都拥有属于它自己的g0外，还存在一个runtime.g0。runtime.g0用于执行引导程序，它运行在Go程序拥有的第一个内核线程之中，这个线程也称为runtime.m0，runtime.m0的g0就是runtime.g0。

## 并发编程
在使用多线程编程时，Go语言需要注意以下几个问题：

内存管理：Go语言的内存管理是基于垃圾回收的，因此在多线程编程中，需要注意避免内存泄漏和竞态条件的问题。可以使用sync包中的锁或者通道来避免竞态条件的出现。

竞态条件：由于多个goroutine可能同时访问同一个共享资源，因此可能会出现竞态条件的问题。竞态条件可能会导致程序出现不可预期的行为，因此需要使用锁或者其他同步机制来避免竞态条件的出现。

调度器：Go语言的调度器会自动将goroutine分配到不同的线程上执行，因此在编写多线程程序时，需要注意避免goroutine之间的依赖关系，避免出现死锁或者饥饿的情况。

并发安全：Go语言的标准库中提供了很多并发安全的数据结构和函数，例如sync包中的锁、atomic包中的原子操作等。在编写多线程程序时，需要使用这些并发安全的机制来保证程序的正确性。

性能优化：Go语言的并发模型可以很好地利用多核处理器的优势，但是在编写多线程程序时，需要注意避免过度使用锁和通道，避免出现性能瓶颈。
